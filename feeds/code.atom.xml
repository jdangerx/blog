<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>John Xia</title><link href="http://jdangerx.github.io/blog/" rel="alternate"></link><link href="http://jdangerx.github.io/blog/feeds/code.atom.xml" rel="self"></link><id>http://jdangerx.github.io/blog/</id><updated>2013-08-13T00:00:00+02:00</updated><entry><title>FourthApp</title><link href="http://jdangerx.github.io/blog/fourthapp.html" rel="alternate"></link><updated>2013-08-13T00:00:00+02:00</updated><author><name>John Xia</name></author><id>tag:jdangerx.github.io/blog,2013-08-13:fourthapp.html</id><summary type="html">&lt;p&gt;I'm currently an intern at
&lt;a href="http://www.missionst.com/"&gt;Mission St. Manufacturing&lt;/a&gt;. We're a 3D
printing company that's trying to streamline 3D printing. If you're
not familiar with 3D printers, imagine building up an object with a
hot glue gun, carefully squeezing out layer upon layer of plastic. Now
imagine a robot doing that.&lt;/p&gt;
&lt;!-- One of the problems we are fixing is that you have to jump through a --&gt;

&lt;!-- ton of hoops to print something. Making a 3D model is hard. Once you --&gt;

&lt;!-- have a model you have to turn that into instructions for your printer, --&gt;

&lt;!-- and once you have the instructions, you have to actually print --&gt;

&lt;!-- them. We hide most of this on our server so nobody has to deal --&gt;

&lt;!-- with it. --&gt;

&lt;!-- You can't hide the actual modeling, so we're making tablet apps that --&gt;

&lt;!-- make simple 3D modeling _really_ simple.  We've got a few in the --&gt;

&lt;!-- works. Let's take a look at one that turns your finger drawings into --&gt;

&lt;!-- real things that you can hold. Its code name is FourthApp. --&gt;

&lt;!-- First you draw something. It's kind of like Paint. No spray-can, though. --&gt;

&lt;!-- (image here) --&gt;

&lt;!-- &lt;\!-- ![](drawView.jpg) -\-&gt; --&gt;

&lt;!-- Then you hit print preview. We turn it into a 3D model and send it --&gt;

&lt;!-- back down for your perusal: --&gt;

&lt;!-- (image here) --&gt;

&lt;!-- &lt;\!-- ![](previewView.jpg) -\-&gt; --&gt;

&lt;!-- If it turns out satisfactorily you can choose to print your part: --&gt;

&lt;!-- (image here) --&gt;

&lt;!-- &lt;\!-- ![](printer.jpg) -\-&gt; --&gt;

&lt;!-- Which ends up looking like this: --&gt;

&lt;!-- (image here) --&gt;

&lt;!-- &lt;\!-- ![](part.jpg) -\-&gt; --&gt;

&lt;!-- You are, no doubt, curious as to how this all works. I'd love to tell --&gt;

&lt;!-- you, but first we need to understand the basics. Namely, what does --&gt;

&lt;!-- making a 3D model entail? Conceptually, it's pretty easy - you take a --&gt;

&lt;!-- picture, figure out what you want the model to look like, and draw --&gt;

&lt;!-- triangles on the model until it's all covered, like this: --&gt;

&lt;!-- &lt;\!-- ![derp](meshlab.jpg) -\-&gt; Once you have that, you can cut it into --&gt;

&lt;!-- thin horizontal slices; then you can write instructions to tell the --&gt;

&lt;!-- printer how to move on each layer. This process is called _toolpath --&gt;

&lt;!-- generation_ or _slicing_. --&gt;

&lt;!-- However, the devil is in the details. We tried several different ways --&gt;

&lt;!-- of making models, which can be lumped into one of two categories: --&gt;

&lt;!-- path-based and image-based. --&gt;

&lt;!-- We started with a path-based method, which works like this: we track --&gt;

&lt;!-- the path the finger traces across the screen. Then we draw two paths --&gt;

&lt;!-- on either side, marking the bottom edges of the model. Then we play --&gt;

&lt;!-- connect-the-dots and make the triangles for the bottom face. Next we --&gt;

&lt;!-- make a copy of the bottom and move it up to make the top --&gt;

&lt;!-- face. Finally, we connect the top and bottom faces to each other to --&gt;

&lt;!-- make the sides. Ta-da! --&gt;

&lt;!-- This runs into some problems, though, when the path crosses over --&gt;

&lt;!-- itself. We end up with some triangles inside the model! The internal --&gt;

&lt;!-- triangles make it hard to determine the border of each slice. This --&gt;

&lt;!-- really messes with your toolpaths. We decided to try to detect the --&gt;

&lt;!-- self-intersections. This worked by checking each edge against each --&gt;

&lt;!-- other edge to see if they crossed. This is slow - when you start --&gt;

&lt;!-- drawing complex pictures, the brush noticeably lags behind your finger --&gt;

&lt;!-- as we accumulate more edges to check. --&gt;

&lt;!-- While trying to fix the code we started thinking about other --&gt;

&lt;!-- approaches. What if we took a screenshot and turned that into a 3D --&gt;

&lt;!-- model? We'd avoid the self-intersecting paths altogether - once you --&gt;

&lt;!-- have painted an area black, it doesn't matter if you go over it --&gt;

&lt;!-- again. It will still be black. It will be black until the end-times, --&gt;

&lt;!-- no matter how many times you draw over it. This was really exciting! --&gt;

&lt;!-- So we started hacking on it. --&gt;

&lt;!-- Soon we had something that kind of worked. The idea is pretty simple: --&gt;

&lt;!-- you look at each pixel in the picture, keeping track of how dark each --&gt;

&lt;!-- pixel is. This will correspond to height later. Each pixel has a 2D --&gt;

&lt;!-- position already. You can put that together with the heights you just --&gt;

&lt;!-- found to get a bunch of 3D points. Then you draw a bunch of triangles --&gt;

&lt;!-- in a giant game of connect-the-three-dimensional-dots, and voila! You --&gt;

&lt;!-- have a 3D model! --&gt;

&lt;!-- This method makes a lot of triangles. In fact, it makes about 10 times --&gt;

&lt;!-- as many as the last one. This means it's 10 times bigger, 10 times --&gt;

&lt;!-- harder to send over the Internet, 10 times harder to slice. To --&gt;

&lt;!-- alleviate these problems, we shrunk down the resolution of the images, --&gt;

&lt;!-- but ran into another snag: at such low resolutions, the beautiful, --&gt;

&lt;!-- organic curves (sensuous, even) that people were drawing became jagged --&gt;

&lt;!-- pixelated blocks. That can be helpful if you are trying to print out --&gt;

&lt;!-- characters from Super Mario, but that's not exactly what we want.  We --&gt;

&lt;!-- tried to find a happy medium between slow and pretty, but it wasn't --&gt;

&lt;!-- there. --&gt;

&lt;!-- Now we've hacked together another solution. The benefit of the --&gt;

&lt;!-- path-based approach is that the model itself is much smaller and --&gt;

&lt;!-- simpler; the benefit of the image-based approach is that we don't have --&gt;

&lt;!-- to deal with self-intersecting curves. A hybrid solution gets us both --&gt;

&lt;!-- of these. The app sends us a picture of what the user has drawn. Then --&gt;

&lt;!-- we use a nice program called --&gt;

&lt;!-- [potrace](http://potrace.sourceforge.net/) to trace the edges of the --&gt;

&lt;!-- drawing. From there, we connect the dots and get a model which is as --&gt;

&lt;!-- simple and smooth as a path-based one without any of the --&gt;

&lt;!-- self-intersection issues. --&gt;

&lt;!-- Of course, there's still ways to improve. I'm working on an extension --&gt;

&lt;!-- to this hybrid method that will let you use different shades of grey --&gt;

&lt;!-- in your drawing to indicate different thicknesses. We can trace those --&gt;

&lt;!-- edges with potrace to get the profile of each slice. Then we can stack --&gt;

&lt;!-- them on top of each other to create the model. This lets you make --&gt;

&lt;!-- things that are bumpy on top. You'd _really_ be getting somewhere. --&gt;

&lt;!-- Astute readers may notice that we don't need to turn the picture into --&gt;

&lt;!-- triangles to make toolpaths. All the printer does is fill in one --&gt;

&lt;!-- horizontal slice of the object and move up, so if we know what each --&gt;

&lt;!-- slice looks like we can make toolpaths straight from that. Luckily, --&gt;

&lt;!-- the different levels of grey represent exactly that! Instead of --&gt;

&lt;!-- stacking the slices, turning that into triangles, then slicing up the --&gt;

&lt;!-- triangles again, we can skip that middle step. This business of --&gt;

&lt;!-- translating between slices and triangles gets into deep waters very --&gt;

&lt;!-- quickly, though, and deserves its own post. --&gt;</summary></entry></feed>